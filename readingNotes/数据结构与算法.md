# 《学习JavaScript数据结构与算法（第3版）》
## 第3章 数组
## 第4章 栈
## 第5章 队列和双端队列
## 第6章 链表
### 6.1 链表数据结构

链表数据：链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成  

单向链表：单向链表有`element`和`next`

### 6.2 双向链表 

双向链表：双向链表有`element`、`next`、`pre`及链表最后一个元素的引用`tail`

### 6.3 循环列表

循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链
表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next ）不是引用
undefined

### 6.4 有序链表

有序链表是指保持元素有序的链表结构
## 第7章 集合

### 7.1 构建数据集合

**集合**是由一组无序且唯一（即不能重复）的项组成的。
```js     
class Set {      
     constructor() { 
        this.items = {}; 
     }
 }
 ``` 
### 7.2 创建集合类
实现集合类的以下方法    
add(element) ：向集合添加一个新元素。  
```js
add(element) {
    if (!this.has(element)) {
        this.items[element] = element; 
            return true;
        }
    return false;
}
```
delete(element) ：从集合移除一个元素。  
```js
    delete (element) {
        if (this.has(element)) {
            delete this.item[element]
            return true
        }
        return false
    }
``` 
has(element) ：如果元素在集合中，返回 true ，否则返回 false 。 
```js
has(element) {
    return element in items;
};
```  
clear() ：移除集合中的所有元素。   
```js
clear () {
    this.item = {}
}
```
size() ：返回集合所包含元素的数量。它与数组的 length 属性类似。 
```js
size () {
    let count = 0
    for (let item in this.item) {
        if(this.items.hasOwnProperty(key)) {
        count++;
        }
    } 
    return count
}
``` 
values() ：返回一个包含集合中所有值（元素）的数组。
```js
values() {
    let tem = []
    for (let item in this.item) {
        if (this.item.hasOwnProperty(item)) {
            tem.push(this.item[item])
        }
    }
    return tem
}
```
### 7.3 集合运算

交集、并集、差集、子集 

## 第8章 字典和散列表

### 8.1 字典

字典则是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组。

### 8.2 散列表
散列算法的作用是尽可能快地在数据结构中找到一个值。   
散列函数
```js
loseloseHashCode(key) {
    if (typeof key === 'number') { // {1}
        return key;
    }
    const tableKey = this.toStrFn(key); // {2}
    let hash = 0; // {3}
    for (let i = 0; i < tableKey.length; i++) {
         hash += tableKey.charCodeAt(i); // {4}
    }
    return hash % 37; // {5}
}
hashCode(key) {
    return this.loseloseHashCode(key);
}
```
#### 8.2.1 创建散列表

## 第9章 递归

## 第10章 树

### 10.1 树数据结构
树是一种分层数据的抽象模型。 

### 10.2 树的相关术语
位于树顶部的节点叫作**根节点** 

树中的每个元素都叫作节点，节点分
为**内部节点**和**外部节点**。

子树由节点和它的后代构成。

### 10.3 二叉树和二叉搜索树
二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。
二叉搜索树（BST）是二叉树的一种

#### 10.4.1 中序遍历
中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序
访问所有节点。
#### 10.4.2 先序遍历
先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构
化的文档。
#### 10.4.3 后序遍历
后序遍历则是先访问节点的后代节点，再访问节点本身。
### 10.5 搜索树中的值
### 10.6 自平衡树
#### 10.6.1 Adelson-Velskii-Landi 树（AVL 树）
计算节点高低
```js
getNodeHeight(node) {
    if (node == null) {
        return -1;
    }
    return Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) + 1;
}
```
平衡因子是他的左右子节点高度的差值， 0、1或1。如果结果不是这三个值之一，则需要平衡该 AVL树。
#### 10.6.2 红黑树
和 AVL树一样，红黑树也是一个自平衡二叉搜索树。  
我们需要一个包含多次插入和删除的自平衡树，红黑树是比较好的。如果
插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL树比红黑树更好。

在红黑树中，每个节点都遵循以下规则：   
(1) 顾名思义，每个节点不是红的就是黑的；   
(2) 树的根节点是黑的；   
(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；   
(4) 如果一个节点是红的，那么它的两个子节点都是黑的；   
(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；    
(6) 从给定的节点到它的后代节点（ NULL 叶节点）的所有路径包含相同数量的黑色节点。

## 第11章 二叉堆和堆排序
### 11.1 二叉堆数据结构
二叉堆是一种特殊的二叉树   
1.它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），
  并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。    
2.二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速
  导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子
  节点。这叫作堆特性
#### 11.1.1 创建最小堆类
在最小堆中，最小值总是位于数组的第一个位置
在最大堆中，最大值总是位于数组的第一个位置

### 11.2 堆排序算法
(1) 用数组创建一个最大堆用作源数据。    
(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个
值，将堆的大小减 1。     
(3) 最后，我们将堆的根节点下移并重复步骤 2直到堆的大小为 1。

## 第12章 图    
图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。
### 12.1 图的相关术语
有向图和无向图
由一条边连接在一起的顶点称为相邻顶点。   
一个顶点的度是其相邻顶点的数量。   
环也是一个简单路径，如果图中不存在环，则称该图是无环的。如果图中每两个顶点间都存在路径，则该图是连通的。
### 12.2 图的表示

#### 12.2.1 邻接矩阵
邻接矩阵表示法不够好
#### 12.2.2 邻接表
邻接表可能对大多数问题来说都是更好的选择
#### 12.2.3 关联矩阵
用于边比点多
### 12.3 创建 Graph 类
```js
class Graph {
    constructor(isDirected = false) {
        this.isDirected = isDirected; // {1}
        this.vertices = []; // {2}
        this.adjList = new Dictionary(); // {3}
    }
}
```
### 12.4 图的遍历
广度优先
搜索（breadth-first search，BFS）和深度优先搜索（depth-first search，DFS）。   
图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探
索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点     
1. 深度优先搜索  栈  将顶点存入栈（在第 4 章中学习过），顶点是沿着路径被探索的，存在新的相邻顶点
就去访问    
2. 广度优先搜索  队列  将顶点存入队列（在第 5章中学习过），最先入队列的顶点先被探索

#### 12.4.1 广度优先搜索    
以下是从顶点 v开始的广度优先搜索算法所遵循的步骤。   
(1) 创建一个队列 Q。   
(2) 标注 v为被发现的（灰色），并将 v入队列 Q。  
(3) 如果 Q非空，则运行以下步骤：  
----(a) 将 u从 Q中出队列；  
----(b) 标注 u为被发现的（灰色）；  
----(c) 将 u所有未被访问过的邻点（白色）入队列；  
----(d) 标注 u为已被探索的（黑色）。
  
1. Dijkstra 算法解决了单源最短路径问题。   
2. Bellman-Ford 算法解决了边权值为负的单源最短路径问题。  
3. A*搜索算法解决了求仅一对顶点间的最短路径问题，用经验法则来加速搜索过程。  
4. Floyd-Warshall 算法解决了求所有顶点对之间的最短路径这一问题。
#### 12.4.2 深度优先搜索

当我们需要编排一些任务或步骤的执行顺序时，这称为拓扑排序  
拓扑排序只能应用于 有向无环图(DAG)。
#### 12.5.1 Dijkstra 算法

Dijkstra算法是一种计算从单个源到所有其他源的最短路径的贪心算法    
一个顶点到其余各顶点的最短路径。  
Floyd-Warshall算法是一种计算图中所有最短路径的动态规划算法  
我们可以找出从所有源到所有顶点的最短路径。
### 12.6 最小生成树

#### 12.6.1 Prim 算法
Prim算法是一种求解加权无向连通图的 MST问题的贪心算法。它能找出一个边的子集，使
得其构成的树包含图中所有顶点，且边的权值之和最小。
Kruskal算法也是一种求加权无向连通图的 MST的贪心算法。

## 第13章 排序和搜索算法    

### 13.1 排序算法
#### 13.1.3 冒泡排序
冒泡排序比较所有相邻的两个项，如果第一个比第二个大，则交换它们。冒泡排序是最差的一个
#### 13.1.2 选择排序
选择排序算法是一种原址比较排序算法。选择排序大致的思路是找到数据结构中的最小值并将其放置在第一位，接着找到第二小的值并将其放在第二位，以此类推。
#### 13.1.3 插入排序
插入排序每次排一个数组项，以此方式构建最后的排序数组。比较大小，放入合适的位置
#### 13.1.4 归并排序
归并排序是第一个可以实际使用的排序算法。你在本书中学到的前三个排序算法性能不好，但归并排序性能不错，其复杂度为 O(nlog(n))。
#### 13.1.5 快速排序
快速排序也许是最常用的排序算法了。它的复杂度为 O(nlog(n))，且性能通常比其他复杂度为 O(nlog(n))的排序算法要好。和归并排序一样，快速排序也使用分而治之的方法，将原始数组分为较小的数组（但它没有像归并排序那样将它们分割开）。
(1) 首先，从数组中选择一个值作为主元（pivot），也就是数组中间的那个值。  
(2) 创建两个指针（引用），左边一个指向数组第一个值，右边一个指向数组最后一个值。移
动左指针直到我们找到一个比主元大的值，接着，移动右指针直到找到一个比主元小的值，然后
交换它们，重复这个过程，直到左指针超过了右指针。这个过程将使得比主元小的值都排在主元
之前，而比主元大的值都排在主元之后。这一步叫作划分（partition）操作。  
(3) 接着，算法对划分后的小数组（较主元小的值组成的子数组，以及较主元大的值组成的
子数组）重复之前的两个步骤，直至数组已完全排序。  
#### 13.1.6 计数排序
计数排序使用一个用来存储每个元素在原始
数组中出现次数的临时数组。在所有元素都计数完成后，临时数组已排好序并可迭代以构建排序
后的结果数组。  
1 创建一个新的数组C，长度length为(max-min+1)  
2 扫描一下数组, C[数组值减去最小值]加一，就是出现的次数  
3 从小到大对比C数组出现的次数，从而来排序。   
#### 13.1.7 桶排序
桶排序（也被称为箱排序）也是分布式排序算法，它将元素分为不同的桶（较小的数组），
再使用一个简单的排序算法，例如插入排序（用来排序小数组的不错的算法），来对每个桶进行
排序。然后，它将所有的桶合并为结果数组。
1 设置桶的大小
2 根据桶地大小，计算有多少个桶
3 根据值得floor看它属于哪个桶
4 然后在单独给每个桶排序组合起来
#### 13.1.8 基数排序

基数排序也是一个分布式排序算法，它根据数字的有效位或基数（这也是它为什么叫基数排
序）将整数分布到桶中。基数是基于数组中值的记数制的。

### 13.2 搜索算法
#### 13.2.1 顺序搜索
顺序或线性搜索是最基本的搜索算法。它的机制是，将每一个数据结构中的元素和我们要找
的元素做比较。顺序搜索是最低效的一种搜索算法。
#### 13.2.2 二分搜索
二分搜索算法的原理和猜数字游戏类似，就是那个有人说“我正想着一个 1～100 的数”的
游戏。我们每回应一个数，那个人就会说这个数是高了、低了还是对了。  
这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤。  
(1) 选择数组的中间值。  
(2) 如果选中值是待搜索值，那么算法执行完毕（值找到了）。  
(3) 如果待搜索值比选中值要小，则返回步骤 1并在选中值左边的子数组中寻找（较小）。  
(4) 如果待搜索值比选中值要大，则返回步骤 1并在选种值右边的子数组中寻找（较大）。  
#### 13.2.3 内插搜索
内插搜索是改良版的二分搜索。二分搜索总是检查 mid 位置上的值，而内插搜索可能会根
据要搜索的值检查数组中的不同地方。
这个算法要求被搜索的数据结构已排序。以下是该算法遵循的步骤：  
(1) 使用 position 公式选中一个值；  
(2) 如果这个值是待搜索值，那么算法执行完毕（值找到了）；  
(3) 如果待搜索值比选中值要小，则返回步骤 1并在选中值左边的子数组中寻找（较小）；  
(4) 如果待搜索值比选中值要大，则返回步骤 1并在选种值右边的子数组中寻找（较大）。  
### 13.3 随机算法
现实中的一个常见场景是洗扑克牌。  
Fisher-Yates 随机
## 第 14 章 算法设计与技巧
### 14.1 分而治之
分而治之是算法设计中的一种方法。它将一个问题分成多个和原问题相似的小问题，递归解决小问题，
再将解决方式合并以解决原来的问题。  
分而治之算法可以分成三个部分。  
(1) 分解原问题为多个子问题（原问题的多个小实例）。  
(2) 解决子问题，用返回解决子问题的方式的递归算法。递归算法的基本情形可以用来解决子
问题。  
(3) 组合这些子问题的解决方式，得到原问题的解。  
### 14.2 动态规划
动态规划（dynamic programming，DP）是一种将复杂问题分解成更小的子问题来解决的优
化技术。   
  
`注意，动态规划和分而治之是不同的方法。分而治之方法是把问题分解成相互独
立的子问题，然后组合它们的答案，而动态规划则是将问题分解成相互依赖的子
问题。`
   
用动态规划解决问题时，要遵循三个重要步骤：  
(1) 定义子问题；   
(2) 实现要反复执行来解决子问题的部分（这一步要参考前一节讨论的递归的步骤）；   
(3) 识别并求解出基线条件(寻找边界条件)。 

#### 14.2.1 最少硬币找零问题  
#### 14.2.2 背包问题  
```js
if (weights[i - 1] <= w) { // {3}
    const a = values[i - 1] + kS[i - 1][w - weights[i - 1]];
    const b = kS[i - 1][w];
    kS[i][w] = a > b ? a : b; // {4} max(a,b)
}
```
#### 14.2.3 最长公共子序列

最长公共子序列(LCS)找出两个字符串序列的最长子序列的长度。最长子序列是指，在两个字符串序列中以相同顺序出现，但不要求
连续（非字符串子串）的字符串序列。
```js
for (let i = 0; i <= m; i++) {
    for (let j = 0; j <= n; j++) {
        if (i === 0 || j === 0) {
            l[i][j] = 0;  
        } 
        else if (wordX[i - 1] === wordY[j - 1]) {
            l[i][j] = l[i - 1][j - 1] + 1; // {3}
        } 
        else {
            const a = l[i - 1][j];
            const b = l[i][j - 1];
            l[i][j] = a > b ? a : b; // {4} max(a,b)
        }
    }
}
```
#### 14.2.4 矩阵链相乘
矩阵链相乘是另一个可以用动态规划解决的著名问题。这个问题是要找出一组矩阵相乘的最
佳方式（顺序）。
### 14.3 贪心算法
贪心算法遵循一种近似解决问题的技术，期盼通过每个阶段的局部最优选择（当前最好的
解），从而达到全局的最优（全局最优解）。它不像动态规划算法那样计算更大的格局。
### 14.4 回溯算法
#### 14.4.1 迷宫老鼠问题
回溯是一种渐进式寻找并构建问题解决方式的策略。我们从一个可能的动作开始并试着用这个动作解决问题。如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回
溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。
```js
function findPath(maze, x, y, solution) {
    const n = maze.length;
    if (x === n - 1 && y === n - 1) { // {4}
        solution[x][y] = 1;
        return true;
    }
    if (isSafe(maze, x, y) === true) { // {5}
        solution[x][y] = 1; // {6}
        if (findPath(maze, x + 1, y, solution)) { // {7}
            return true;
        }
        if (findPath(maze, x, y + 1, solution)) { // {8}
            return true;
        }
        solution[x][y] = 0; // {9}
        return false;
    }
    return false; // {10}
}
```
#### 14.4.2 数独解题器
目标是用数字 1～9 填满一个 9 × 9的矩阵，要求每行和每列都由这九个数字构成。矩阵还包含了小方块（3 × 3矩阵），它
们同样需要分别用这九个数字填满
### 14.5 函数式编程简介
#### 14.5.1 函数式编程与命令式编程
在命令式编程中，我们按部就班地编写程序代码，详细描述要完成的事情以及完成的顺序。

函数式编程有以下几点要注意。  
1.函数式编程的主要目标是描述数据，以及要对数据应用的转换。  
2.在函数式编程中，程序执行顺序的重要性很低；而在命令式编程中，步骤和顺序是非常
重要的。  
3.函数和数据集合是函数式编程的核心。  
4.在函数式编程中，我们可以使用和滥用函数和递归；而在命令式编程中，则使用循环、
赋值、条件和函数。  
5.在函数式编程中，要避免副作用和可变数据，意味着我们不会修改传入函数的数据。如
果需要基于输入返回一个解决方案，可以制作一个副本并返回数据修改后的副本。 

##  第 15 章 算法复杂度
### 15.1 大 O 表示法