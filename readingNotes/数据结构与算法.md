# 《学习JavaScript数据结构与算法（第3版）》
## 第3章 数组
## 第4章 栈
## 第5章 队列和双端队列
## 第6章 链表
### 6.1 链表数据结构

链表数据：链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成  

单向链表：单向链表有`element`和`next`

### 6.2 双向链表 

双向链表：双向链表有`element`、`next`、`pre`及链表最后一个元素的引用`tail`

### 6.3 循环列表

循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链
表之间唯一的区别在于，最后一个元素指向下一个元素的指针（ tail.next ）不是引用
undefined

### 6.4 有序链表

有序链表是指保持元素有序的链表结构
## 第7章 集合

### 7.1 构建数据集合

**集合**是由一组无序且唯一（即不能重复）的项组成的。
```js     
class Set {      
     constructor() { 
        this.items = {}; 
     }
 }
 ``` 
### 7.2 创建集合类
实现集合类的以下方法    
add(element) ：向集合添加一个新元素。  
```js
add(element) {
    if (!this.has(element)) {
        this.items[element] = element; 
            return true;
        }
    return false;
}
```
delete(element) ：从集合移除一个元素。  
```js
    delete (element) {
        if (this.has(element)) {
            delete this.item[element]
            return true
        }
        return false
    }
``` 
has(element) ：如果元素在集合中，返回 true ，否则返回 false 。 
```js
has(element) {
    return element in items;
};
```  
clear() ：移除集合中的所有元素。   
```js
clear () {
    this.item = {}
}
```
size() ：返回集合所包含元素的数量。它与数组的 length 属性类似。 
```js
size () {
    let count = 0
    for (let item in this.item) {
        if(this.items.hasOwnProperty(key)) {
        count++;
        }
    } 
    return count
}
``` 
values() ：返回一个包含集合中所有值（元素）的数组。
```js
values() {
    let tem = []
    for (let item in this.item) {
        if (this.item.hasOwnProperty(item)) {
            tem.push(this.item[item])
        }
    }
    return tem
}
```
### 7.3 集合运算

交集、并集、差集、子集 

## 第8章 字典和散列表

### 8.1 字典

字典则是以[键，值]的形式来存储元素。字典也称作映射、符号表或关联数组。

### 8.2 散列表
散列算法的作用是尽可能快地在数据结构中找到一个值。   
散列函数
```js
loseloseHashCode(key) {
    if (typeof key === 'number') { // {1}
        return key;
    }
    const tableKey = this.toStrFn(key); // {2}
    let hash = 0; // {3}
    for (let i = 0; i < tableKey.length; i++) {
         hash += tableKey.charCodeAt(i); // {4}
    }
    return hash % 37; // {5}
}
hashCode(key) {
    return this.loseloseHashCode(key);
}
```
#### 8.2.1 创建散列表

## 第9章 递归

## 第10章 树

### 10.1 树数据结构
树是一种分层数据的抽象模型。 

### 10.2 树的相关术语
位于树顶部的节点叫作**根节点** 

树中的每个元素都叫作节点，节点分
为**内部节点**和**外部节点**。

子树由节点和它的后代构成。

### 10.3 二叉树和二叉搜索树
二叉树中的节点最多只能有两个子节点：一个是左侧子节点，另一个是右侧子节点。
二叉搜索树（BST）是二叉树的一种

#### 10.4.1 中序遍历
中序遍历是一种以上行顺序访问 BST 所有节点的遍历方式，也就是以从最小到最大的顺序
访问所有节点。
#### 10.4.2 先序遍历
先序遍历是以优先于后代节点的顺序访问每个节点的。先序遍历的一种应用是打印一个结构
化的文档。
#### 10.4.3 后序遍历
后序遍历则是先访问节点的后代节点，再访问节点本身。
### 10.5 搜索树中的值
### 10.6 自平衡树
#### 10.6.1 Adelson-Velskii-Landi 树（AVL 树）
计算节点高低
```js
getNodeHeight(node) {
    if (node == null) {
        return -1;
    }
    return Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) + 1;
}
```
平衡因子是他的左右子节点高度的差值， 0、1或1。如果结果不是这三个值之一，则需要平衡该 AVL树。
#### 10.6.2 红黑树
和 AVL树一样，红黑树也是一个自平衡二叉搜索树。  
我们需要一个包含多次插入和删除的自平衡树，红黑树是比较好的。如果
插入和删除频率较低（我们更需要多次进行搜索操作），那么 AVL树比红黑树更好。

在红黑树中，每个节点都遵循以下规则：   
(1) 顾名思义，每个节点不是红的就是黑的；   
(2) 树的根节点是黑的；   
(3) 所有叶节点都是黑的（用 NULL 引用表示的节点）；   
(4) 如果一个节点是红的，那么它的两个子节点都是黑的；   
(5) 不能有两个相邻的红节点，一个红节点不能有红的父节点或子节点；    
(6) 从给定的节点到它的后代节点（ NULL 叶节点）的所有路径包含相同数量的黑色节点。

## 第11章 二叉堆和堆排序
### 11.1 二叉堆数据结构
二叉堆是一种特殊的二叉树   
1.它是一棵完全二叉树，表示树的每一层都有左侧和右侧子节点（除了最后一层的叶节点），
  并且最后一层的叶节点尽可能都是左侧子节点，这叫作结构特性。    
2.二叉堆不是最小堆就是最大堆。最小堆允许你快速导出树的最小值，最大堆允许你快速
  导出树的最大值。所有的节点都大于等于（最大堆）或小于等于（最小堆）每个它的子
  节点。这叫作堆特性
#### 11.1.1 创建最小堆类
在最小堆中，最小值总是位于数组的第一个位置
在最大堆中，最大值总是位于数组的第一个位置

### 11.2 堆排序算法
(1) 用数组创建一个最大堆用作源数据。    
(2) 在创建最大堆后，最大的值会被存储在堆的第一个位置。我们要将它替换为堆的最后一个
值，将堆的大小减 1。     
(3) 最后，我们将堆的根节点下移并重复步骤 2直到堆的大小为 1。

## 第12章 图    
图是网络结构的抽象模型。图是一组由边连接的节点（或顶点）。
有向图和无向图
